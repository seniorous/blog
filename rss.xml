<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>少游的博客</title><description>去追寻吧，你所期待的那颗星</description><link>https://mizuki-sooty.vercel.app/</link><language>zh_CN</language><item><title>Git 实战指南：从分支管理到远程协作</title><link>https://mizuki-sooty.vercel.app/posts/git-practice-guide/</link><guid isPermaLink="true">https://mizuki-sooty.vercel.app/posts/git-practice-guide/</guid><description>从真实开发场景出发，梳理 Git 在分支管理、合并策略、撤销操作与远程协作中的核心实践。</description><pubDate>Tue, 24 Feb 2026 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Git 实战指南：从分支管理到远程协作&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;本文从实际开发场景出发，梳理 Git 在日常工作中最常遇到的操作与决策。不讲花哨技巧，只聚焦「遇到这种情况该怎么办」。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr /&gt;
&lt;h2&gt;一、分支：Git 的核心工作单元&lt;/h2&gt;
&lt;p&gt;在团队开发中，分支是隔离工作的基本手段。你不会直接在 &lt;code&gt;main&lt;/code&gt; 上写代码——你会创建一个分支，在上面开发，完成后再合并回去。&lt;/p&gt;
&lt;h3&gt;创建与切换&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 创建并切换到新分支（推荐写法）
git checkout -b feature

# 等价于两步操作
git branch feature
git checkout feature
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;HEAD 是什么？&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;HEAD&lt;/code&gt; 是一个指针，指向你当前所在的分支（或提交）。你做的每一次 &lt;code&gt;checkout&lt;/code&gt; 都在移动它。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;HEAD^&lt;/code&gt; — 当前提交的父节点&lt;/li&gt;
&lt;li&gt;&lt;code&gt;HEAD~3&lt;/code&gt; — 往前数 3 个提交&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git branch -f main HEAD~2&lt;/code&gt; — 强制把 main 指针移到前 2 个提交&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面这张图展示了一个典型的分支工作流——从 &lt;code&gt;main&lt;/code&gt; 创建 &lt;code&gt;feature&lt;/code&gt; 和 &lt;code&gt;bugfix&lt;/code&gt; 分支，独立开发后合并回主干：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mizuki-sooty.vercel.app/images/git-practice-guide/svg1_branch_workflow.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;二、merge vs rebase：最常见的选择困难&lt;/h2&gt;
&lt;p&gt;这是 Git 使用中最核心的决策之一。两者都能把代码合到一起，但适用场景完全不同。&lt;/p&gt;
&lt;h3&gt;merge：保留历史轨迹&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 在 main 上执行，合并 feature 分支
git checkout main
git merge --no-ff feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;--no-ff&lt;/code&gt; 强制生成一个合并提交，即使可以快进。这样在历史中能清楚看到「这个功能是从哪里合进来的」。&lt;/p&gt;
&lt;h3&gt;rebase：保持线性历史&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 在 feature 上执行，把自己的改动「垫」到 main 最新提交之上
git checkout feature
git rebase main
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;rebase 的本质是：暂存你的提交 → 应用目标分支的更新 → 重新应用你的提交。注意，它修改的是&lt;strong&gt;当前分支&lt;/strong&gt;，目标分支只是参照物。&lt;/p&gt;
&lt;h3&gt;黄金法则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;个人分支用 rebase&lt;/strong&gt;：保持干净的线性历史&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;公共分支用 merge&lt;/strong&gt;：保留合并记录，不改写已推送的历史&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;已推送的分支禁止 rebase&lt;/strong&gt;：会导致其他人的历史混乱&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://mizuki-sooty.vercel.app/images/git-practice-guide/svg2_merge_vs_rebase.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;三、撤销操作：出了问题怎么办？&lt;/h2&gt;
&lt;p&gt;开发中难免会提交错误的代码。关键问题是：&lt;strong&gt;这个提交已经推送到远程了吗？&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;仅本地：git reset&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 撤销最近一次提交，保留改动在暂存区
git reset --soft HEAD^

# 撤销最近一次提交，保留改动在工作区（默认行为）
git reset HEAD^

# 彻底丢弃改动（不可恢复！）
git reset --hard HEAD^
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;已推送：git revert&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 生成一个新的「反向提交」来撤销指定提交
git revert &amp;lt;commit-hash&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;revert&lt;/code&gt; 不会改写历史，而是创建一个新提交来抵消之前的改动。这在协作中是安全的。&lt;/p&gt;
&lt;h3&gt;cherry-pick：精确挑选&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 只把 C2 和 C4 这两个提交挪到当前分支
git cherry-pick C2 C4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;区别于 &lt;code&gt;rebase&lt;/code&gt; 拿整个分支，&lt;code&gt;cherry-pick&lt;/code&gt; 让你精确选择需要的提交。&lt;/p&gt;
&lt;h3&gt;交互式 rebase：整理本地提交&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;git rebase -i HEAD~4
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以重排、合并、删除、编辑最近 4 个提交。在推送前整理提交历史非常有用。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mizuki-sooty.vercel.app/images/git-practice-guide/svg3_undo_decision.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;四、远程协作：本地与远程的同步&lt;/h2&gt;
&lt;h3&gt;核心概念&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;origin/main&lt;/code&gt;（简写 &lt;code&gt;o/main&lt;/code&gt;）是本地存储的远程仓库快照&lt;/li&gt;
&lt;li&gt;它不会自动更新，需要手动 &lt;code&gt;fetch&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;fetch、pull、push 的关系&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 只更新远程跟踪分支，不动本地分支（安全）
git fetch origin

# 拉取并合并（= fetch + merge）
git pull origin main

# 拉取并变基（= fetch + rebase，推荐）
git pull --rebase

# 推送本地提交到远程
git push origin main
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Remote Tracking：分支跟踪&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 创建本地分支并跟踪远程分支
git checkout -b feature o/main

# 为已有分支设置跟踪
git branch -u o/main feature
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置跟踪后，&lt;code&gt;git push&lt;/code&gt; 和 &lt;code&gt;git pull&lt;/code&gt; 就知道该推到哪里、从哪里拉了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mizuki-sooty.vercel.app/images/git-practice-guide/svg4_remote_collab.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;五、push / fetch / pull 参数详解&lt;/h2&gt;
&lt;p&gt;这三个命令都支持 &lt;code&gt;origin &amp;lt;source&amp;gt;:&amp;lt;destination&amp;gt;&lt;/code&gt; 的参数格式，但方向相反：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;push&lt;/strong&gt;：本地 → 远程（推送空 source = 删除远程分支）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;fetch&lt;/strong&gt;：远程 → 本地（拉取空 source = 创建本地分支）&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;# push 的 source:destination
git push origin main           # 本地 main → 远程 main
git push origin local:remote   # 本地 local → 远程 remote
git push origin :remote        # 删除远程 remote 分支

# fetch 的 source:destination（方向相反）
git fetch origin main           # 远程 main → 本地 o/main
git fetch origin remote:local   # 远程 remote → 本地 local
git fetch origin :local         # 创建本地 local 分支

# pull 是 fetch + merge 的组合
git pull origin foo             # = fetch origin foo + merge o/foo
git pull origin bar:bugFix      # = fetch origin bar:bugFix + merge bugFix
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://mizuki-sooty.vercel.app/images/git-practice-guide/svg5_push_fetch_pull.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;六、现代 Git 协作利器：worktree&lt;/h2&gt;
&lt;h3&gt;为什么需要 worktree？&lt;/h3&gt;
&lt;p&gt;在实际开发中，你经常会遇到这样的场景：正在 &lt;code&gt;feature&lt;/code&gt; 分支上写代码写到一半，突然线上出了 bug 需要紧急修复。传统做法是 &lt;code&gt;git stash&lt;/code&gt; → 切分支 → 修 bug → 切回来 → &lt;code&gt;git stash pop&lt;/code&gt;。这个流程有几个痛点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;stash 恢复时可能产生冲突&lt;/li&gt;
&lt;li&gt;IDE 的构建缓存、运行状态全部丢失&lt;/li&gt;
&lt;li&gt;频繁切换分支的心智负担很重&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;git worktree&lt;/code&gt; 从根本上解决了这个问题：它允许你从同一个仓库创建多个工作目录，每个目录检出不同的分支，彼此完全独立。&lt;/p&gt;
&lt;h3&gt;核心设计理念&lt;/h3&gt;
&lt;p&gt;worktree 的设计哲学是&lt;strong&gt;共享存储，隔离工作区&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有工作树共享同一个 &lt;code&gt;.git&lt;/code&gt; 对象库（commits、blobs、trees）&lt;/li&gt;
&lt;li&gt;每个工作树有独立的 &lt;code&gt;HEAD&lt;/code&gt;、&lt;code&gt;index&lt;/code&gt;（暂存区）和工作目录&lt;/li&gt;
&lt;li&gt;磁盘开销极小——只多了一份工作区文件，不会复制整个仓库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这意味着你在任何一个工作树中做的提交，其他工作树都能立即看到（通过 &lt;code&gt;git log&lt;/code&gt;），因为底层数据是共享的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mizuki-sooty.vercel.app/images/git-practice-guide/svg6_worktree_concept.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;实战场景对比&lt;/h3&gt;
&lt;p&gt;下面这张图对比了传统方式和 worktree 方式处理「开发中途需要修 bug」的流程差异：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://mizuki-sooty.vercel.app/images/git-practice-guide/svg7_worktree_workflow.svg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;常用命令速查&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 创建一个新的工作树，检出 hotfix 分支
git worktree add ../project-hotfix hotfix

# 创建工作树的同时创建新分支
git worktree add -b emergency-fix ../project-fix main

# 查看所有工作树
git worktree list

# 完成后移除工作树（先删目录再清理引用）
git worktree remove ../project-hotfix

# 清理已失效的工作树引用
git worktree prune
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;使用注意事项&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;同一分支不能同时被两个工作树检出&lt;/strong&gt;——这是 Git 的硬性限制，防止两个工作区同时修改同一分支导致混乱&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;不要直接 &lt;code&gt;rm -rf&lt;/code&gt; 删除工作树目录&lt;/strong&gt;——应该用 &lt;code&gt;git worktree remove&lt;/code&gt;，否则 &lt;code&gt;.git/worktrees&lt;/code&gt; 中会残留失效引用&lt;/li&gt;
&lt;li&gt;子模块在链接工作树中的支持有限，复杂项目需要测试验证&lt;/li&gt;
&lt;li&gt;worktree 非常适合 CI/CD 场景——可以同时构建多个分支而不互相干扰&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;什么时候该用 worktree？&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;场景&lt;/th&gt;
&lt;th&gt;是否推荐&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;开发中途需要紧急修 bug&lt;/td&gt;
&lt;td&gt;✅ 最佳场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;需要同时对比两个分支的运行效果&lt;/td&gt;
&lt;td&gt;✅ 非常适合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;长期维护多个版本（v1、v2）&lt;/td&gt;
&lt;td&gt;✅ 比多个 clone 更轻量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;CI 并行构建多个分支&lt;/td&gt;
&lt;td&gt;✅ 共享对象库，节省空间&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;只是简单切个分支看一眼&lt;/td&gt;
&lt;td&gt;❌ 直接 checkout 更快&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;h2&gt;七、实战工作流总结&lt;/h2&gt;
&lt;h3&gt;日常开发流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;git fetch origin&lt;/code&gt; — 先看看远程有什么变化&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git rebase o/main&lt;/code&gt; — 在个人分支上变基到最新&lt;/li&gt;
&lt;li&gt;解决可能的冲突&lt;/li&gt;
&lt;li&gt;&lt;code&gt;git push&lt;/code&gt; — 推送到远程&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;main&lt;/code&gt; 上 &lt;code&gt;merge --no-ff&lt;/code&gt; — 合并功能分支&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;版本标记&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;# 给特定提交打标签
git tag v1.0.0 &amp;lt;commit-hash&amp;gt;

# 查看离当前位置最近的标签
git describe main
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常见陷阱&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;陷阱&lt;/th&gt;
&lt;th&gt;后果&lt;/th&gt;
&lt;th&gt;正确做法&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;在公共分支上 rebase&lt;/td&gt;
&lt;td&gt;其他人的历史被打乱&lt;/td&gt;
&lt;td&gt;只在个人分支 rebase&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;rebase 时搞反目标和参考分支&lt;/td&gt;
&lt;td&gt;提交顺序错乱&lt;/td&gt;
&lt;td&gt;仔细确认当前分支和目标分支&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;reset --hard 后想恢复&lt;/td&gt;
&lt;td&gt;改动永久丢失&lt;/td&gt;
&lt;td&gt;先确认不需要，或用 reflog 抢救&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;push 空 source 到远程&lt;/td&gt;
&lt;td&gt;远程分支被删除&lt;/td&gt;
&lt;td&gt;检查命令参数再执行&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;hr /&gt;
&lt;blockquote&gt;
&lt;p&gt;记住两条核心原则：&lt;strong&gt;个人分支随便折腾，公共分支只做加法&lt;/strong&gt;。掌握了 merge/rebase 的选择和 reset/revert 的区分，日常 Git 操作就不会出大问题。&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded></item></channel></rss>