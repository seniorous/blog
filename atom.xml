<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>少游的博客</title>
  <subtitle>去追寻吧，你所期待的那颗星</subtitle>
  <link href="https://mizuki-sooty.vercel.app/" rel="alternate" type="text/html"/>
  <link href="https://mizuki-sooty.vercel.app/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://mizuki-sooty.vercel.app/</id>
  <updated>2026-02-27T04:12:13.551Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>Python3 核心概念回顾</title>
    <link href="https://mizuki-sooty.vercel.app/posts/python3-review/" rel="alternate" type="text/html"/>
    <id>https://mizuki-sooty.vercel.app/posts/python3-review/</id>
    <published>2026-02-25T00:00:00.000Z</published>
    <updated>2026-02-25T00:00:00.000Z</updated>
    <summary>回顾 Python3 中字典、列表、函数、模块、推导式、迭代器、生成器、装饰器等核心概念。</summary>
    <content type="html"><![CDATA[<h2>python回顾</h2>
<p>字典（键与值一一对应），列表（自由的数组），元组（只读列表，成员不变）
列表需要注意的是extend，appendix，pop等
字典（列表不可以作为键，因为其需要不可变）</p>
<h3>函数</h3>
<p>函数中需要理解的一点是变量与类型的区别：类型是真实存在的，变量只不过的指向类型的标签，所以python中的变量才可以自由变换。
也是因此所以可变和不可变变量的根本区别是：
修改可变变量的时候，是修改了类型本身，而修改不可变变量的时候，是修改了标签所引用的对象
对象有类型，变量无类型</p>
<h5>局部变量与全局变量</h5>
<p>局部标签与全局标签，可以使用global进行遮蔽</p>
<h5>参数</h5>
<p>必备参数
关键字参数
这两个区别主要是传参的时候有没有显式的写出，如果没有，就会按照必备参数一个个按顺序填，关键字参数则可以在顺序不对的时候也自动匹配填入
可变参数
使用 * args把所有参数吸收
默认参数
如果不传就用默认值</p>
<h3>模块</h3>
<p>不要用from...import*（命名空间污染）
直接import的时候，加入库名称.函数
补充__name__函数
一个模块被另一个程序第一次引入时，其主程序将运行。</p>
<p>如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用 <strong>name</strong> 属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code>#!/usr/bin/python3
# Filename: using_name.py

if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
</code></pre>
<p>运行输出如下：</p>
<pre><code>$ python using_name.py
程序自身在运行

$ python
&gt;&gt;&gt; import using_name
我来自另一模块
</code></pre>
<p>说明：每个模块都有一个 <code>__name__</code> 属性。</p>
<ul>
<li>如果模块是被直接运行，<code>__name__</code> 的值为 <code>__main__</code>。</li>
<li>如果模块是被导入的，<code>__name__</code> 的值为模块名。</li>
</ul>
<h3>推导式</h3>
<pre><code># 列表
[out_exp_res for out_exp in input_list if condition]
[函数 for 变量 in 列表 if 条件]

# 字典
{ key_expr: value_expr for value in collection if condition }

# 集合
{ expression for item in Sequence if conditional }

# 元组
(expression for item in Sequence if conditional)
</code></pre>
<h3>迭代器与生成器</h3>
<h4>iter()</h4>
<p>创建迭代器对象</p>
<h4>next()</h4>
<p>迭代器循环，可以使用 <code>raise StopIteration</code> 来结束迭代</p>
<h4>生成器</h4>
<h5>yield</h5>
<ul>
<li><strong>产出值并暂停：</strong> 当程序执行到 <code>yield</code> 时，它会向调用者返回 <code>yield</code> 后面的值，然后<strong>立刻暂停</strong>在这一行代码，停止向下执行。</li>
<li><strong>保留运行状态：</strong> 函数被暂停时，它内部所有的变量状态、指令指针等都会被完整保留下来。</li>
<li><strong>恢复执行：</strong> 当我们下次再调用 <code>next()</code> 方法请求数据时，代码会从上次 <code>yield</code> 暂停的地方<strong>紧接着往下执行</strong>，直到遇到下一个 <code>yield</code></li>
</ul>
<pre><code>def countdown(n):
    while n &gt; 0:
        yield n
        n -= 1

# 创建生成器对象
generator = countdown(5)

# 通过迭代生成器获取值
print(next(generator))  # 输出: 5
print(next(generator))  # 输出: 4
print(next(generator))  # 输出: 3

# 使用 for 循环迭代生成器
for value in generator:
    print(value)  # 输出: 2 1
</code></pre>
<h3>with 语句</h3>
<p>使用with来管理资源分布</p>
<p>想要使用with的对象需要有<code>__enter__</code> 和<code>__exit__</code>方法，帮助自动处理与释放资源</p>
<pre><code># 同时打开多个文件
with open('input.txt', 'r') as infile, open('output.txt', 'w') as outfile:
    content = infile.read()
    outfile.write(content.upper())
</code></pre>
<h4>最佳实践</h4>
<ol>
<li><strong>优先使用 with 管理资源</strong>：对于文件、网络连接、锁等资源，总是优先考虑使用 <code>with</code> 语句</li>
<li><strong>保持上下文简洁</strong>：<code>with</code> 块中的代码应该只包含与资源相关的操作</li>
<li><strong>合理处理异常</strong>：在自定义上下文管理器中，根据需求决定是否抑制异常</li>
<li><strong>利用多个上下文</strong>：Python 允许在单个 <code>with</code> 语句中管理多个资源</li>
</ol>
<h3>lambda</h3>
<pre><code>lambda arguments: expression
</code></pre>
<pre><code>numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
print(squared)  # 输出: [1, 4, 9, 16, 25]
</code></pre>
<h3>装饰器</h3>
<h4>函数装饰器</h4>
<p>Python 装饰器允许在不修改原有函数代码的基础上，动态地增加或修改函数的功能，装饰器本质上是一个接收函数作为输入并返回一个新的包装过后的函数的对象。
本质上是接收函数返回wrapper</p>
<pre><code>def my_decorator(func):
    def wrapper():
        print("在原函数之前执行")
        func()
        print("在原函数之后执行")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
</code></pre>
<p>疑问：return在这里起什么作用？
外层return是my_decorator，作用是把被装饰函数替换成wrapper函数。</p>
<ul>
<li>加上括号 <code>wrapper()</code>：意思是"立刻执行这个函数，并把执行后的<strong>结果</strong>交出去"。</li>
<li>不加括号 <code>wrapper</code>：意思是"我不执行它，我把这个函数的**本体（遥控器）**直接交出去"。</li>
</ul>
<pre><code>def my_decorator(func):
    # 这里是外层函数
    print("【额外逻辑】我在定义时就被执行了！")
    return func  # 只能把原函数原封不动地退回去

@my_decorator
def greet(name):
    print(f"Hello, {name}!")

# 当代码运行到上面 @my_decorator 那里时，屏幕上就已经打印了：
# 【额外逻辑】我在定义时就被执行了！

# 等你真正在下面调用函数时：
greet("Alice")
greet("Bob")

# 屏幕上只会输出：
# Hello, Alice!
# Hello, Bob!
</code></pre>
<p>一般来说，这一块最关键的就是一个 return，和一个内部的内置函数wrapper()，在被定义的时候呢，它这个被装饰 F 就可以执行它这个里特，并且反将被装饰 F 替换成装饰后的函数。
然后以后的话，当我们调用被装饰函数的时候，就是默认被替换成装饰后函数。遵循里面的逻辑，这个装饰后函数我们一般使用就是wrapper</p>
<p>所以在使用可变参数传参的时候，应该遵循这样一个原则：</p>
<p><strong>1. <code>*args</code> (Arguments：位置参数打包器)</strong></p>
<ul>
<li><strong>作用：</strong> 负责把所有按顺序传入的参数，打包成一个<strong>元组 (Tuple)</strong>。</li>
<li><strong>示例：</strong> 如果你调用 <code>func("Alice", 25, "Beijing")</code>，那么在函数内部，<code>args</code> 就会变成 <code>("Alice", 25, "Beijing")</code>。</li>
</ul>
<p><strong>2. <code>**kwargs</code> (Keyword Arguments：关键字参数打包器)</strong></p>
<ul>
<li><strong>作用：</strong> 负责把所有带有名字的参数（如 <code>name="Alice"</code>），打包成一个<strong>字典 (Dictionary)</strong>。</li>
<li><strong>示例：</strong> 如果你调用 <code>func(name="Alice", age=25)</code>，那么在函数内部，<code>kwargs</code> 就会变成 <code>{"name": "Alice", "age": 25}</code>。</li>
</ul>
<h4>类的装饰器</h4>
<table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>核心标志</strong></th>
<th><strong>作用目标</strong></th>
<th><strong>核心优势</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类装饰器 (用类写)</strong></td>
<td>实现 <code>__init__</code> 和 <code>__call__</code></td>
<td>装饰普通的函数</td>
<td>极其擅长管理复杂的<strong>状态</strong>（如计数、缓存）。</td>
</tr>
<tr>
<td><strong>装饰类的装饰器</strong></td>
<td>接收参数 <code>cls</code> 代替 <code>func</code></td>
<td>装饰一个 Class</td>
<td>批量给类<strong>动态添加属性或方法</strong>，减少重复的模板代码。</td>
</tr>
</tbody>
</table>
<p><code>__call__</code> 等于 wrapper</p>
<pre><code>class Retry:
    def __init__(self, max_times=3):
        # 1. 装配阶段的第一步：记录装饰器传进来的参数
        print(f"【初始化】设置最大重试次数为: {max_times}")
        self.max_times = max_times

    def __call__(self, func):
        # 2. 装配阶段的第二步：接收原函数，并制造替身
        print(f"【装配时】正在给函数 {func.__name__} 穿上重试外套...")

        def wrapper(*args, **kwargs):
            # 3. 调用阶段：真正的重试逻辑
            for attempt in range(1, self.max_times + 1):
                try:
                    print(f"  -&gt; 第 {attempt} 次尝试执行...")
                    result = func(*args, **kwargs)
                    print("  -&gt; 执行成功！")
                    return result  # 成功就直接返回结果，结束循环

                except Exception as e:
                    print(f"  -&gt; 失败了，错误原因: {e}")

            print(f"❌ 警告：已达到最大重试次数 {self.max_times}，彻底放弃。")

        return wrapper  # 把替身交出去

# === 使用场景 ===
print("---- 代码开始加载 ----")

@Retry(max_times=3)
def unstable_network_request():
    # 模拟一个不稳定的网络请求，我们让它故意报错
    raise ConnectionError("网络波动，连接超时！")

print("\n---- 准备调用 ----")
unstable_network_request()
</code></pre>
<p>注意这里存在的身份信息问题：</p>
<pre><code>def my_decorator(func):
    @wraps(func)  # 用这个让wrap继承身份信息
    def wrapper(*args, **kwargs):
        """我是 wrapper 函数的注释"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def calculate_tax(amount):
    """这是一个用来计算税务的复杂核心函数"""
    return amount * 0.2

# 此时我们想打印一下函数的名字和注释文档
print(calculate_tax.__name__)
print(calculate_tax.__doc__)
</code></pre>
<table>
<thead>
<tr>
<th><strong>装饰器</strong></th>
<th><strong>第一个参数</strong></th>
<th><strong>能否访问实例属性 (self.xxx)?</strong></th>
<th><strong>能否访问类属性 (cls.xxx)?</strong></th>
<th><strong>最常见使用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>(普通方法)</strong></td>
<td><code>self</code> (实例)</td>
<td>✅ 能</td>
<td>✅ 能 (通过 <code>self.__class__</code>)</td>
<td>操作或修改单个对象的具体状态。</td>
</tr>
<tr>
<td><strong><code>@property</code></strong></td>
<td><code>self</code> (实例)</td>
<td>✅ 能</td>
<td>✅ 能</td>
<td>把方法伪装成只读属性，动态计算值或保护数据。</td>
</tr>
<tr>
<td><strong><code>@classmethod</code></strong></td>
<td><code>cls</code> (类)</td>
<td>❌ 不能</td>
<td>✅ 能</td>
<td>作为"备用构造函数"，或修改全局类状态。</td>
</tr>
<tr>
<td><strong><code>@staticmethod</code></strong></td>
<td>(无固定参数)</td>
<td>❌ 不能</td>
<td>❌ 不能</td>
<td>编写与类逻辑相关，但纯独立的工具函数。</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>少游</name>
    </author>
    <category term="编程语言"></category>
  </entry>
  <entry>
    <title>Python3 核心概念精讲：从基础到面向对象</title>
    <link href="https://mizuki-sooty.vercel.app/posts/python3-core-guide/" rel="alternate" type="text/html"/>
    <id>https://mizuki-sooty.vercel.app/posts/python3-core-guide/</id>
    <published>2026-02-25T00:00:00.000Z</published>
    <updated>2026-02-25T00:00:00.000Z</updated>
    <summary>系统梳理 Python3 核心概念，深入讲解装饰器机制、面向对象编程思想、异常处理策略，每个知识点配备开发最佳实践。</summary>
    <content type="html"><![CDATA[<h1>Python3 核心概念精讲：从基础到面向对象</h1>
<blockquote>
<p>本文从 Python 的对象模型出发，系统梳理数据结构、函数、装饰器、面向对象、异常处理等核心概念。每个知识点都配有实际开发中的最佳实践，帮助你写出更 Pythonic 的代码。</p>
</blockquote>
<hr />
<h2>一、Python 对象模型：一切皆对象</h2>
<p>Python 中最重要的认知转变是：<strong>变量不是盒子，而是标签</strong>。</p>
<p>类型（对象）是内存中真实存在的实体，变量只是贴在对象上的名字。这就是为什么 Python 的变量可以随时指向不同类型的对象——因为变量本身没有类型，<strong>对象才有类型</strong>。</p>
<pre><code>a = 10       # a 是一个标签，贴在 int 对象 10 上
a = "hello"  # 同一个标签 a，现在贴到了 str 对象上
a = [1, 2]   # 又贴到了 list 对象上
</code></pre>
<h3>可变与不可变的本质区别</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>不可变 (Immutable)</th>
<th>可变 (Mutable)</th>
</tr>
</thead>
<tbody>
<tr>
<td>代表</td>
<td><code>int</code>, <code>str</code>, <code>tuple</code>, <code>frozenset</code></td>
<td><code>list</code>, <code>dict</code>, <code>set</code></td>
</tr>
<tr>
<td>修改行为</td>
<td>创建新对象，标签重新指向</td>
<td>原地修改同一对象</td>
</tr>
<tr>
<td><code>id()</code> 变化</td>
<td>变化（新对象）</td>
<td>不变（同一对象）</td>
</tr>
</tbody>
</table>
<pre><code># 不可变：重新赋值 = 标签换对象
a = 10
print(id(a))  # 140234866423056
a = 20
print(id(a))  # 140234866423376 ← 不同的对象

# 可变：修改 = 原地改对象
b = [1, 2, 3]
print(id(b))  # 140234851234560
b.append(4)
print(id(b))  # 140234851234560 ← 同一个对象！
</code></pre>
<p><img src="https://mizuki-sooty.vercel.app/images/python3-core-guide/svg1_python_object_model.svg" alt="Python 对象模型" /></p>
<blockquote>
<p><strong>最佳实践：</strong> 函数参数传递可变对象时，函数内部的修改会影响外部。防御性编程应在函数内部使用 <code>data.copy()</code> 或切片 <code>data[:]</code> 创建副本。</p>
</blockquote>
<hr />
<h2>二、数据结构速览</h2>
<h3>列表 (List)</h3>
<p>Python 的列表是动态数组，支持任意类型混合存储。</p>
<pre><code>fruits = ["apple", "banana", "cherry"]

# 常用操作
fruits.append("date")       # 末尾添加
fruits.extend(["fig", "grape"])  # 批量追加（注意和 append 的区别）
fruits.insert(1, "avocado") # 指定位置插入
fruits.pop()                # 弹出末尾元素
fruits.pop(0)               # 弹出指定位置
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> <code>append</code> 添加单个元素，<code>extend</code> 合并列表。误用 <code>append</code> 传入列表会产生嵌套：<code>[1, [2, 3]]</code> 而非 <code>[1, 2, 3]</code>。</p>
</blockquote>
<h3>字典 (Dict)</h3>
<p>键值对映射，键必须是不可变类型（因为需要哈希）。</p>
<pre><code>user = {"name": "Alice", "age": 25}

# 安全取值
user.get("email", "未设置")  # 不存在时返回默认值，不会抛 KeyError

# Python 3.9+ 合并语法
defaults = {"theme": "dark", "lang": "zh"}
config = defaults | user  # 合并字典，右侧优先
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> 用 <code>dict.get(key, default)</code> 替代 <code>dict[key]</code>，避免 <code>KeyError</code>。需要带默认值的字典用 <code>collections.defaultdict</code>。</p>
</blockquote>
<h3>元组 (Tuple)</h3>
<p>不可变的序列，常用于函数多返回值和作为字典的键。</p>
<pre><code># 函数返回多个值本质是返回元组
def get_user():
    return "Alice", 25, "alice@example.com"

name, age, email = get_user()  # 解包
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> 当数据不应被修改时用元组替代列表，既表达意图又略微提升性能。命名元组 <code>collections.namedtuple</code> 或 <code>typing.NamedTuple</code> 让元组更具可读性。</p>
</blockquote>
<hr />
<h2>三、函数进阶</h2>
<h3>参数类型全解</h3>
<p>Python 函数参数有四种传递方式，理解它们的优先级和组合规则至关重要：</p>
<pre><code>def example(
    name,                  # 必备参数（位置参数）
    age=25,                # 默认参数
    *args,                 # 可变位置参数 → 打包为元组
    **kwargs               # 可变关键字参数 → 打包为字典
):
    print(f"{name}, {age}")
    print(f"额外位置参数: {args}")
    print(f"额外关键字参数: {kwargs}")

example("Alice", 30, "extra1", "extra2", city="Beijing")
# Alice, 30
# 额外位置参数: ('extra1', 'extra2')
# 额外关键字参数: {'city': 'Beijing'}
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> 默认参数不要用可变对象！<code>def f(data=[])</code> 是经典陷阱——所有调用共享同一个列表。正确写法：<code>def f(data=None): data = data or []</code>。</p>
</blockquote>
<h3>作用域与 <code>global</code> / <code>nonlocal</code></h3>
<pre><code>count = 0

def increment():
    global count    # 声明使用全局变量
    count += 1

def outer():
    x = 10
    def inner():
        nonlocal x  # 声明使用外层函数的变量
        x += 1
    inner()
    print(x)  # 11
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> 尽量避免 <code>global</code>，它会让代码难以追踪和测试。如果需要共享状态，用类封装或者依赖注入。</p>
</blockquote>
<hr />
<h2>四、模块与包</h2>
<h3><code>import</code> 的正确姿势</h3>
<pre><code># ✗ 不推荐：命名空间污染，不知道函数来自哪里
from os import *

# ✓ 推荐：明确来源
import os
os.path.join("/home", "user")

# ✓ 推荐：只导入需要的
from os.path import join, exists
</code></pre>
<h3><code>__name__</code> 的作用</h3>
<p>每个模块都有 <code>__name__</code> 属性。直接运行时值为 <code>"__main__"</code>，被导入时值为模块名。</p>
<pre><code># utils.py
def helper():
    return "I'm a helper"

if __name__ == "__main__":
    # 只在直接运行 utils.py 时执行
    # 被其他模块 import 时不会执行
    print(helper())
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> 所有脚本都应该有 <code>if __name__ == "__main__"</code> 守卫。这样模块既可以被导入复用，也可以独立运行测试。</p>
</blockquote>
<hr />
<h2>五、推导式：Pythonic 的数据变换</h2>
<p>推导式是 Python 最优雅的特性之一，用一行代码完成数据的过滤和变换：</p>
<pre><code># 列表推导式
squares = [x**2 for x in range(10) if x % 2 == 0]
# [0, 4, 16, 36, 64]

# 字典推导式
word_lengths = {word: len(word) for word in ["hello", "world", "python"]}
# {'hello': 5, 'world': 5, 'python': 6}

# 集合推导式（自动去重）
unique_lengths = {len(word) for word in ["hi", "hello", "hey"]}
# {2, 5, 3}

# 生成器表达式（惰性求值，不占内存）
total = sum(x**2 for x in range(1000000))
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> 推导式应保持简洁。如果逻辑超过一行或需要多层嵌套，改用普通 <code>for</code> 循环更易读。嵌套推导式超过两层就是代码异味。</p>
</blockquote>
<hr />
<h2>六、迭代器与生成器</h2>
<h3>迭代器协议</h3>
<p>任何实现了 <code>__iter__()</code> 和 <code>__next__()</code> 方法的对象都是迭代器。<code>for</code> 循环的本质就是不断调用 <code>next()</code> 直到 <code>StopIteration</code>。</p>
<pre><code>nums = [1, 2, 3]
it = iter(nums)       # 获取迭代器
print(next(it))       # 1
print(next(it))       # 2
print(next(it))       # 3
# next(it)            # StopIteration!
</code></pre>
<h3>生成器：优雅的迭代器</h3>
<p>生成器是创建迭代器的简洁方式。函数中包含 <code>yield</code> 关键字就自动变成生成器函数。</p>
<p><code>yield</code> 的三个关键行为：</p>
<ol>
<li><strong>产出值并暂停</strong> — 返回值给调用者，然后冻结在当前位置</li>
<li><strong>保留运行状态</strong> — 所有局部变量、执行位置都被保存</li>
<li><strong>恢复执行</strong> — 下次 <code>next()</code> 从暂停处继续</li>
</ol>
<pre><code>def countdown(n):
    while n &gt; 0:
        yield n    # 产出 n，暂停
        n -= 1     # 下次 next() 从这里继续

gen = countdown(5)
print(next(gen))  # 5
print(next(gen))  # 4

for val in gen:   # 继续迭代剩余的
    print(val)    # 3, 2, 1
</code></pre>
<p><img src="https://mizuki-sooty.vercel.app/images/python3-core-guide/svg5_iterator_generator.svg" alt="迭代器 vs 生成器" /></p>
<blockquote>
<p><strong>最佳实践：</strong> 处理大数据集时，生成器是救星。读取 10GB 日志文件：用 <code>for line in open("huge.log")</code> 而非 <code>open("huge.log").readlines()</code>，前者逐行生成，后者一次性加载到内存。</p>
</blockquote>
<hr />
<h2>七、with 语句与上下文管理器</h2>
<p><code>with</code> 语句确保资源（文件、锁、连接）在使用后被正确释放，即使发生异常。</p>
<pre><code># 文件操作：with 自动关闭文件
with open("data.txt", "r") as f:
    content = f.read()
# 离开 with 块后，f 自动关闭，即使中间抛了异常

# 同时管理多个资源
with open("input.txt") as infile, open("output.txt", "w") as outfile:
    outfile.write(infile.read().upper())
</code></pre>
<h3>自定义上下文管理器</h3>
<p>实现 <code>__enter__</code> 和 <code>__exit__</code> 方法，或使用 <code>contextlib.contextmanager</code> 装饰器：</p>
<pre><code>from contextlib import contextmanager
import time

@contextmanager
def timer(label):
    start = time.perf_counter()
    yield  # 这里是 with 块内的代码执行点
    elapsed = time.perf_counter() - start
    print(f"{label}: {elapsed:.4f}s")

with timer("数据处理"):
    data = [x**2 for x in range(1000000)]
# 输出: 数据处理: 0.0823s
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> 任何需要"获取-使用-释放"模式的场景都应该用 <code>with</code>：文件、数据库连接、线程锁、临时目录。<code>contextlib</code> 模块提供了 <code>suppress</code>、<code>redirect_stdout</code> 等实用工具。</p>
</blockquote>
<hr />
<h2>八、Lambda 表达式</h2>
<p>Lambda 是匿名的单行函数，适合作为高阶函数的参数：</p>
<pre><code># 排序：按字典的 age 字段
users = [{"name": "Bob", "age": 30}, {"name": "Alice", "age": 25}]
sorted_users = sorted(users, key=lambda u: u["age"])

# 配合 map/filter
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))      # [1, 4, 9, 16, 25]
evens = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong> Lambda 只用于简单的单行逻辑。如果需要多行或复杂逻辑，定义具名函数更清晰。PEP 8 明确建议不要把 lambda 赋值给变量（<code>f = lambda x: x+1</code>），直接用 <code>def</code> 。</p>
</blockquote>
<hr />
<h2>九、装饰器深入</h2>
<p>装饰器是 Python 最强大的元编程工具之一。它允许在不修改原函数代码的前提下，动态增强函数的功能。</p>
<h3>函数装饰器的本质</h3>
<p><code>@decorator</code> 是语法糖，等价于 <code>func = decorator(func)</code>。装饰器接收一个函数，返回一个新函数（通常是 <code>wrapper</code>）。</p>
<pre><code>import functools

def log_calls(func):
    @functools.wraps(func)  # 保留原函数的元信息
    def wrapper(*args, **kwargs):
        print(f"→ 调用 {func.__name__}({args}, {kwargs})")
        result = func(*args, **kwargs)
        print(f"← {func.__name__} 返回 {result}")
        return result
    return wrapper

@log_calls
def add(a, b):
    """两数相加"""
    return a + b

add(3, 5)
# → 调用 add((3, 5), {})
# ← add 返回 8
</code></pre>
<h3>理解 <code>return wrapper</code> vs <code>return wrapper()</code></h3>
<p>这是初学者最容易混淆的点：</p>
<ul>
<li><code>return wrapper</code> — 返回函数本体（遥控器），以后调用时才执行</li>
<li><code>return wrapper()</code> — 立即执行函数，返回执行结果</li>
</ul>
<p>装饰器必须返回函数本体，否则装饰后的函数就不是函数了。</p>
<h3>带参数的装饰器（三层嵌套）</h3>
<p>当装饰器本身需要接收参数时，需要多包一层：</p>
<pre><code>import functools

def retry(max_times=3, delay=1):
    """带参数的重试装饰器"""
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(1, max_times + 1):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    print(f"第 {attempt} 次失败: {e}")
                    if attempt == max_times:
                        raise
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_times=3, delay=2)
def fetch_data(url):
    # 网络请求逻辑...
    pass
</code></pre>
<h3>用类实现装饰器</h3>
<p>当装饰器需要管理复杂状态（如计数、缓存）时，用类实现更清晰：</p>
<pre><code>class CallCounter:
    def __init__(self, func):
        functools.update_wrapper(self, func)
        self.func = func
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"{self.func.__name__} 已被调用 {self.count} 次")
        return self.func(*args, **kwargs)

@CallCounter
def process():
    pass

process()  # process 已被调用 1 次
process()  # process 已被调用 2 次
</code></pre>
<p><code>__call__</code> 方法让类的实例可以像函数一样被调用，它就是类装饰器中的 <code>wrapper</code>。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/python3-core-guide/svg2_decorator_mechanism.svg" alt="装饰器执行机制" /></p>
<blockquote>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>始终使用 <code>@functools.wraps(func)</code></strong> — 保留原函数的 <code>__name__</code>、<code>__doc__</code> 等元信息</li>
<li><strong>wrapper 必须接受 <code>*args, **kwargs</code></strong> — 确保兼容任意函数签名</li>
<li><strong>常用内置装饰器：</strong> <code>@property</code>、<code>@classmethod</code>、<code>@staticmethod</code>、<code>@functools.lru_cache</code></li>
</ol>
</blockquote>
<hr />
<h2>十、面向对象编程</h2>
<p>面向对象是 Python 的核心编程范式。Python 的 OOP 哲学可以用一句话概括：<strong>一切皆对象，鸭子类型优先</strong>。</p>
<h3>类的基本结构</h3>
<pre><code>class User:
    """用户类"""
    # 类属性：所有实例共享
    platform = "MyApp"

    def __init__(self, name: str, email: str):
        # 实例属性：每个实例独立
        self.name = name
        self.email = email
        self._login_count = 0       # 约定私有（单下划线）
        self.__password_hash = ""   # 名称改写（双下划线）

    def login(self):
        """普通方法：操作实例状态"""
        self._login_count += 1
        return f"{self.name} 登录成功（第 {self._login_count} 次）"

    @property
    def login_count(self):
        """属性装饰器：像属性一样访问，但有控制逻辑"""
        return self._login_count

    @classmethod
    def from_dict(cls, data: dict):
        """类方法：备用构造函数"""
        return cls(data["name"], data["email"])

    @staticmethod
    def validate_email(email: str) -&gt; bool:
        """静态方法：纯工具函数"""
        return "@" in email and "." in email
</code></pre>
<h3>封装：保护数据完整性</h3>
<p>Python 没有真正的 <code>private</code> 关键字，而是通过命名约定实现封装：</p>
<ul>
<li><code>_name</code> — 约定私有，外部不应直接访问（但技术上可以）</li>
<li><code>__name</code> — 名称改写（Name Mangling），变成 <code>_ClassName__name</code>，更强的保护</li>
<li><code>name_</code> — 避免与关键字冲突，如 <code>class_</code>、<code>type_</code></li>
</ul>
<pre><code>class BankAccount:
    def __init__(self, balance: float):
        self.__balance = balance  # 双下划线保护

    @property
    def balance(self) -&gt; float:
        """只读属性"""
        return self.__balance

    def deposit(self, amount: float):
        if amount &lt;= 0:
            raise ValueError("存款金额必须为正数")
        self.__balance += amount

    def withdraw(self, amount: float):
        if amount &gt; self.__balance:
            raise ValueError("余额不足")
        self.__balance -= amount
</code></pre>
<h3>继承与方法重写</h3>
<pre><code>class Animal:
    def __init__(self, name: str):
        self.name = name

    def speak(self) -&gt; str:
        raise NotImplementedError("子类必须实现 speak 方法")

class Dog(Animal):
    def speak(self) -&gt; str:
        return f"{self.name}: 汪汪！"

class Cat(Animal):
    def speak(self) -&gt; str:
        return f"{self.name}: 喵~"

# 多态：同一接口，不同行为
animals = [Dog("旺财"), Cat("咪咪")]
for animal in animals:
    print(animal.speak())
</code></pre>
<h3>多继承与 MRO</h3>
<p>Python 支持多继承，方法解析顺序（MRO）遵循 C3 线性化算法：</p>
<pre><code>class A:
    def greet(self):
        return "A"

class B(A):
    def greet(self):
        return "B"

class C(A):
    def greet(self):
        return "C"

class D(B, C):
    pass

d = D()
print(d.greet())       # "B" — 按 MRO 顺序
print(D.__mro__)       # (D, B, C, A, object)
</code></pre>
<h3><code>super()</code> 的正确用法</h3>
<pre><code>class Student(User):
    def __init__(self, name: str, email: str, grade: int):
        super().__init__(name, email)  # 调用父类构造
        self.grade = grade

    def login(self):
        result = super().login()  # 调用父类方法
        return f"{result}（学生用户）"
</code></pre>
<h3>鸭子类型：Python 的多态哲学</h3>
<p>Python 不需要显式的接口声明。只要对象有正确的方法，就可以使用：</p>
<pre><code>class FileLogger:
    def write(self, msg):
        with open("app.log", "a") as f:
            f.write(msg + "\n")

class ConsoleLogger:
    def write(self, msg):
        print(f"[LOG] {msg}")

def log_message(logger, msg):
    """不关心 logger 的类型，只要有 write 方法就行"""
    logger.write(msg)

# 两种 logger 都能用，这就是鸭子类型
log_message(FileLogger(), "保存到文件")
log_message(ConsoleLogger(), "打印到控制台")
</code></pre>
<p><img src="https://mizuki-sooty.vercel.app/images/python3-core-guide/svg3_oop_three_pillars.svg" alt="面向对象三大支柱" /></p>
<p><img src="https://mizuki-sooty.vercel.app/images/python3-core-guide/svg6_class_decorators.svg" alt="类方法装饰器对比" /></p>
<blockquote>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>优先组合而非继承</strong> — 继承层级不超过 3 层，复杂关系用 "has-a" 替代 "is-a"</li>
<li><strong>使用 ABC 定义接口</strong> — <code>from abc import ABC, abstractmethod</code> 强制子类实现特定方法</li>
<li><strong>单一职责</strong> — 每个类只做一件事，如果类名里有 "And"，说明该拆分了</li>
<li><strong>用 <code>dataclass</code> 简化数据类</strong> — Python 3.7+ 的 <code>@dataclass</code> 自动生成 <code>__init__</code>、<code>__repr__</code> 等</li>
</ol>
</blockquote>
<hr />
<h2>十一、异常处理</h2>
<p>在 AI 辅助编程时代，Debug 能力是重中之重。异常处理不仅是捕获错误，更是一种防御性编程策略。</p>
<h3>完整的异常处理结构</h3>
<pre><code>try:
    result = 10 / int(input("输入除数: "))
except ValueError:
    print("请输入有效的数字")
except ZeroDivisionError:
    print("除数不能为零")
except Exception as e:
    print(f"未预期的错误: {e}")
else:
    # 只在 try 块没有异常时执行
    print(f"结果: {result}")
finally:
    # 无论如何都会执行（资源清理）
    print("计算结束")
</code></pre>
<h3>异常的传播规则</h3>
<p>如果异常在 <code>try</code>（或 <code>except</code>、<code>else</code>）中被抛出，且没有被任何 <code>except</code> 捕获，它会在 <code>finally</code> 执行完毕后继续向上传播。</p>
<h3>自定义异常</h3>
<pre><code>class AppError(Exception):
    """应用基础异常"""
    pass

class ValidationError(AppError):
    """数据验证异常"""
    def __init__(self, field: str, message: str):
        self.field = field
        self.message = message
        super().__init__(f"{field}: {message}")

class NotFoundError(AppError):
    """资源未找到"""
    pass

# 使用
def create_user(name: str, age: int):
    if not name:
        raise ValidationError("name", "用户名不能为空")
    if age &lt; 0 or age &gt; 150:
        raise ValidationError("age", "年龄必须在 0-150 之间")
</code></pre>
<h3><code>raise</code> 的三种用法</h3>
<pre><code># 1. 抛出新异常
raise ValueError("无效的输入")

# 2. 重新抛出当前异常（保留原始堆栈）
try:
    risky_operation()
except Exception:
    logging.error("操作失败")
    raise  # 不带参数，原样抛出

# 3. 异常链（Python 3）
try:
    data = json.loads(raw)
except json.JSONDecodeError as e:
    raise ValidationError("data", "JSON 格式错误") from e
</code></pre>
<p><img src="https://mizuki-sooty.vercel.app/images/python3-core-guide/svg4_exception_handling.svg" alt="异常处理流程" /></p>
<blockquote>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>永远不要裸 <code>except:</code></strong> — 至少用 <code>except Exception</code>，否则会吞掉 <code>KeyboardInterrupt</code> 和 <code>SystemExit</code></li>
<li><strong>精确捕获</strong> — <code>except ValueError</code> 优于 <code>except Exception</code>，只处理你知道如何处理的异常</li>
<li><strong>自定义异常继承 <code>Exception</code></strong> — 不要继承 <code>BaseException</code></li>
<li><strong>用 <code>raise ... from e</code> 保留异常链</strong> — 方便调试时追溯根因</li>
<li><strong>日志记录用 <code>logging.exception()</code></strong> — 自动包含堆栈信息</li>
</ol>
</blockquote>
<hr />
<h2>十二、类型注解</h2>
<p>Python 3.5+ 引入的类型注解不影响运行时行为，但能极大提升代码可读性和 IDE 支持：</p>
<pre><code>from typing import Optional, Union

def find_user(user_id: int) -&gt; Optional[dict]:
    """查找用户，不存在返回 None"""
    ...

def process(data: list[dict[str, Union[str, int]]]) -&gt; float:
    """处理数据列表"""
    ...

# Python 3.10+ 更简洁的语法
def greet(name: str | None = None) -&gt; str:
    return f"Hello, {name or 'World'}"
</code></pre>
<blockquote>
<p><strong>最佳实践：</strong></p>
<ol>
<li><strong>渐进式采用</strong> — 从公共接口和复杂函数开始，不需要一次性全部注解</li>
<li><strong>配合 mypy 使用</strong> — <code>pip install mypy &amp;&amp; mypy your_project/</code> 静态类型检查</li>
<li><strong>避免过度注解</strong> — <code>x: int = 5</code> 是多余的，类型显而易见时可以省略</li>
</ol>
</blockquote>
<hr />
<h2>总结</h2>
<p>Python 的核心哲学是 <strong>"简洁优于复杂，可读性至上"</strong>。掌握这些核心概念后，关键是在实际项目中不断实践：</p>
<ul>
<li><strong>对象模型</strong> 让你理解 Python 的运行机制</li>
<li><strong>装饰器</strong> 让你写出优雅的横切关注点代码</li>
<li><strong>面向对象</strong> 让你构建可维护的大型系统</li>
<li><strong>异常处理</strong> 让你的代码在生产环境中稳健运行</li>
</ul>
<p>记住：Pythonic 的代码不是炫技，而是让下一个读代码的人（包括未来的你）能快速理解意图。</p>
]]></content>
    <author>
      <name>少游</name>
    </author>
    <category term="编程语言"></category>
  </entry>
  <entry>
    <title>Git 实战指南：从分支管理到远程协作</title>
    <link href="https://mizuki-sooty.vercel.app/posts/git-practice-guide/" rel="alternate" type="text/html"/>
    <id>https://mizuki-sooty.vercel.app/posts/git-practice-guide/</id>
    <published>2026-02-24T00:00:00.000Z</published>
    <updated>2026-02-24T00:00:00.000Z</updated>
    <summary>从真实开发场景出发，梳理 Git 在分支管理、合并策略、撤销操作与远程协作中的核心实践。</summary>
    <content type="html"><![CDATA[<h1>Git 实战指南：从分支管理到远程协作</h1>
<blockquote>
<p>本文从实际开发场景出发，梳理 Git 在日常工作中最常遇到的操作与决策。不讲花哨技巧，只聚焦「遇到这种情况该怎么办」。</p>
</blockquote>
<hr />
<h2>一、分支：Git 的核心工作单元</h2>
<p>在团队开发中，分支是隔离工作的基本手段。你不会直接在 <code>main</code> 上写代码——你会创建一个分支，在上面开发，完成后再合并回去。</p>
<h3>创建与切换</h3>
<pre><code># 创建并切换到新分支（推荐写法）
git checkout -b feature

# 等价于两步操作
git branch feature
git checkout feature
</code></pre>
<h3>HEAD 是什么？</h3>
<p><code>HEAD</code> 是一个指针，指向你当前所在的分支（或提交）。你做的每一次 <code>checkout</code> 都在移动它。</p>
<ul>
<li><code>HEAD^</code> — 当前提交的父节点</li>
<li><code>HEAD~3</code> — 往前数 3 个提交</li>
<li><code>git branch -f main HEAD~2</code> — 强制把 main 指针移到前 2 个提交</li>
</ul>
<p>下面这张图展示了一个典型的分支工作流——从 <code>main</code> 创建 <code>feature</code> 和 <code>bugfix</code> 分支，独立开发后合并回主干：</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg1_branch_workflow.svg" alt="" /></p>
<hr />
<h2>二、merge vs rebase：最常见的选择困难</h2>
<p>这是 Git 使用中最核心的决策之一。两者都能把代码合到一起，但适用场景完全不同。</p>
<h3>merge：保留历史轨迹</h3>
<pre><code># 在 main 上执行，合并 feature 分支
git checkout main
git merge --no-ff feature
</code></pre>
<p><code>--no-ff</code> 强制生成一个合并提交，即使可以快进。这样在历史中能清楚看到「这个功能是从哪里合进来的」。</p>
<h3>rebase：保持线性历史</h3>
<pre><code># 在 feature 上执行，把自己的改动「垫」到 main 最新提交之上
git checkout feature
git rebase main
</code></pre>
<p>rebase 的本质是：暂存你的提交 → 应用目标分支的更新 → 重新应用你的提交。注意，它修改的是<strong>当前分支</strong>，目标分支只是参照物。</p>
<h3>黄金法则</h3>
<ul>
<li><strong>个人分支用 rebase</strong>：保持干净的线性历史</li>
<li><strong>公共分支用 merge</strong>：保留合并记录，不改写已推送的历史</li>
<li><strong>已推送的分支禁止 rebase</strong>：会导致其他人的历史混乱</li>
</ul>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg2_merge_vs_rebase.svg" alt="" /></p>
<hr />
<h2>三、撤销操作：出了问题怎么办？</h2>
<p>开发中难免会提交错误的代码。关键问题是：<strong>这个提交已经推送到远程了吗？</strong></p>
<h3>仅本地：git reset</h3>
<pre><code># 撤销最近一次提交，保留改动在暂存区
git reset --soft HEAD^

# 撤销最近一次提交，保留改动在工作区（默认行为）
git reset HEAD^

# 彻底丢弃改动（不可恢复！）
git reset --hard HEAD^
</code></pre>
<h3>已推送：git revert</h3>
<pre><code># 生成一个新的「反向提交」来撤销指定提交
git revert &lt;commit-hash&gt;
</code></pre>
<p><code>revert</code> 不会改写历史，而是创建一个新提交来抵消之前的改动。这在协作中是安全的。</p>
<h3>cherry-pick：精确挑选</h3>
<pre><code># 只把 C2 和 C4 这两个提交挪到当前分支
git cherry-pick C2 C4
</code></pre>
<p>区别于 <code>rebase</code> 拿整个分支，<code>cherry-pick</code> 让你精确选择需要的提交。</p>
<h3>交互式 rebase：整理本地提交</h3>
<pre><code>git rebase -i HEAD~4
</code></pre>
<p>可以重排、合并、删除、编辑最近 4 个提交。在推送前整理提交历史非常有用。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg3_undo_decision.svg" alt="" /></p>
<hr />
<h2>四、远程协作：本地与远程的同步</h2>
<h3>核心概念</h3>
<ul>
<li><code>origin/main</code>（简写 <code>o/main</code>）是本地存储的远程仓库快照</li>
<li>它不会自动更新，需要手动 <code>fetch</code></li>
</ul>
<h3>fetch、pull、push 的关系</h3>
<pre><code># 只更新远程跟踪分支，不动本地分支（安全）
git fetch origin

# 拉取并合并（= fetch + merge）
git pull origin main

# 拉取并变基（= fetch + rebase，推荐）
git pull --rebase

# 推送本地提交到远程
git push origin main
</code></pre>
<h3>Remote Tracking：分支跟踪</h3>
<pre><code># 创建本地分支并跟踪远程分支
git checkout -b feature o/main

# 为已有分支设置跟踪
git branch -u o/main feature
</code></pre>
<p>设置跟踪后，<code>git push</code> 和 <code>git pull</code> 就知道该推到哪里、从哪里拉了。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg4_remote_collab.svg" alt="" /></p>
<hr />
<h2>五、push / fetch / pull 参数详解</h2>
<p>这三个命令都支持 <code>origin &lt;source&gt;:&lt;destination&gt;</code> 的参数格式，但方向相反：</p>
<ul>
<li><strong>push</strong>：本地 → 远程（推送空 source = 删除远程分支）</li>
<li><strong>fetch</strong>：远程 → 本地（拉取空 source = 创建本地分支）</li>
</ul>
<pre><code># push 的 source:destination
git push origin main           # 本地 main → 远程 main
git push origin local:remote   # 本地 local → 远程 remote
git push origin :remote        # 删除远程 remote 分支

# fetch 的 source:destination（方向相反）
git fetch origin main           # 远程 main → 本地 o/main
git fetch origin remote:local   # 远程 remote → 本地 local
git fetch origin :local         # 创建本地 local 分支

# pull 是 fetch + merge 的组合
git pull origin foo             # = fetch origin foo + merge o/foo
git pull origin bar:bugFix      # = fetch origin bar:bugFix + merge bugFix
</code></pre>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg5_push_fetch_pull.svg" alt="" /></p>
<hr />
<h2>六、现代 Git 协作利器：worktree</h2>
<h3>为什么需要 worktree？</h3>
<p>在实际开发中，你经常会遇到这样的场景：正在 <code>feature</code> 分支上写代码写到一半，突然线上出了 bug 需要紧急修复。传统做法是 <code>git stash</code> → 切分支 → 修 bug → 切回来 → <code>git stash pop</code>。这个流程有几个痛点：</p>
<ul>
<li>stash 恢复时可能产生冲突</li>
<li>IDE 的构建缓存、运行状态全部丢失</li>
<li>频繁切换分支的心智负担很重</li>
</ul>
<p><code>git worktree</code> 从根本上解决了这个问题：它允许你从同一个仓库创建多个工作目录，每个目录检出不同的分支，彼此完全独立。</p>
<h3>核心设计理念</h3>
<p>worktree 的设计哲学是<strong>共享存储，隔离工作区</strong>：</p>
<ul>
<li>所有工作树共享同一个 <code>.git</code> 对象库（commits、blobs、trees）</li>
<li>每个工作树有独立的 <code>HEAD</code>、<code>index</code>（暂存区）和工作目录</li>
<li>磁盘开销极小——只多了一份工作区文件，不会复制整个仓库</li>
</ul>
<p>这意味着你在任何一个工作树中做的提交，其他工作树都能立即看到（通过 <code>git log</code>），因为底层数据是共享的。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg6_worktree_concept.svg" alt="" /></p>
<h3>实战场景对比</h3>
<p>下面这张图对比了传统方式和 worktree 方式处理「开发中途需要修 bug」的流程差异：</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg7_worktree_workflow.svg" alt="" /></p>
<h3>常用命令速查</h3>
<pre><code># 创建一个新的工作树，检出 hotfix 分支
git worktree add ../project-hotfix hotfix

# 创建工作树的同时创建新分支
git worktree add -b emergency-fix ../project-fix main

# 查看所有工作树
git worktree list

# 完成后移除工作树（先删目录再清理引用）
git worktree remove ../project-hotfix

# 清理已失效的工作树引用
git worktree prune
</code></pre>
<h3>使用注意事项</h3>
<ul>
<li><strong>同一分支不能同时被两个工作树检出</strong>——这是 Git 的硬性限制，防止两个工作区同时修改同一分支导致混乱</li>
<li><strong>不要直接 <code>rm -rf</code> 删除工作树目录</strong>——应该用 <code>git worktree remove</code>，否则 <code>.git/worktrees</code> 中会残留失效引用</li>
<li>子模块在链接工作树中的支持有限，复杂项目需要测试验证</li>
<li>worktree 非常适合 CI/CD 场景——可以同时构建多个分支而不互相干扰</li>
</ul>
<h3>什么时候该用 worktree？</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发中途需要紧急修 bug</td>
<td>✅ 最佳场景</td>
</tr>
<tr>
<td>需要同时对比两个分支的运行效果</td>
<td>✅ 非常适合</td>
</tr>
<tr>
<td>长期维护多个版本（v1、v2）</td>
<td>✅ 比多个 clone 更轻量</td>
</tr>
<tr>
<td>CI 并行构建多个分支</td>
<td>✅ 共享对象库，节省空间</td>
</tr>
<tr>
<td>只是简单切个分支看一眼</td>
<td>❌ 直接 checkout 更快</td>
</tr>
</tbody>
</table>
<hr />
<h2>七、实战工作流总结</h2>
<h3>日常开发流程</h3>
<ol>
<li><code>git fetch origin</code> — 先看看远程有什么变化</li>
<li><code>git rebase o/main</code> — 在个人分支上变基到最新</li>
<li>解决可能的冲突</li>
<li><code>git push</code> — 推送到远程</li>
<li>在 <code>main</code> 上 <code>merge --no-ff</code> — 合并功能分支</li>
</ol>
<h3>版本标记</h3>
<pre><code># 给特定提交打标签
git tag v1.0.0 &lt;commit-hash&gt;

# 查看离当前位置最近的标签
git describe main
</code></pre>
<h3>常见陷阱</h3>
<table>
<thead>
<tr>
<th>陷阱</th>
<th>后果</th>
<th>正确做法</th>
</tr>
</thead>
<tbody>
<tr>
<td>在公共分支上 rebase</td>
<td>其他人的历史被打乱</td>
<td>只在个人分支 rebase</td>
</tr>
<tr>
<td>rebase 时搞反目标和参考分支</td>
<td>提交顺序错乱</td>
<td>仔细确认当前分支和目标分支</td>
</tr>
<tr>
<td>reset --hard 后想恢复</td>
<td>改动永久丢失</td>
<td>先确认不需要，或用 reflog 抢救</td>
</tr>
<tr>
<td>push 空 source 到远程</td>
<td>远程分支被删除</td>
<td>检查命令参数再执行</td>
</tr>
</tbody>
</table>
<hr />
<blockquote>
<p>记住两条核心原则：<strong>个人分支随便折腾，公共分支只做加法</strong>。掌握了 merge/rebase 的选择和 reset/revert 的区分，日常 Git 操作就不会出大问题。</p>
</blockquote>
]]></content>
    <author>
      <name>少游</name>
    </author>
    <category term="开发工具"></category>
  </entry>
</feed>