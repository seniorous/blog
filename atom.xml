<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>少游的博客</title>
  <subtitle>去追寻吧，你所期待的那颗星</subtitle>
  <link href="https://mizuki-sooty.vercel.app/" rel="alternate" type="text/html"/>
  <link href="https://mizuki-sooty.vercel.app/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://mizuki-sooty.vercel.app/</id>
  <updated>2026-02-25T13:59:02.048Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>Python3 核心概念回顾</title>
    <link href="https://mizuki-sooty.vercel.app/posts/python3-review/" rel="alternate" type="text/html"/>
    <id>https://mizuki-sooty.vercel.app/posts/python3-review/</id>
    <published>2026-02-24T00:00:00.000Z</published>
    <updated>2026-02-24T00:00:00.000Z</updated>
    <summary>回顾 Python3 中字典、列表、函数、模块、推导式、迭代器、生成器、装饰器等核心概念。</summary>
    <content type="html"><![CDATA[<h2>python回顾</h2>
<p>字典（键与值一一对应），列表（自由的数组），元组（只读列表，成员不变）
列表需要注意的是extend，appendix，pop等
字典（列表不可以作为键，因为其需要不可变）</p>
<h3>函数</h3>
<p>函数中需要理解的一点是变量与类型的区别：类型是真实存在的，变量只不过的指向类型的标签，所以python中的变量才可以自由变换。
也是因此所以可变和不可变变量的根本区别是：
修改可变变量的时候，是修改了类型本身，而修改不可变变量的时候，是修改了标签所引用的对象
对象有类型，变量无类型</p>
<h5>局部变量与全局变量</h5>
<p>局部标签与全局标签，可以使用global进行遮蔽</p>
<h5>参数</h5>
<p>必备参数
关键字参数
这两个区别主要是传参的时候有没有显式的写出，如果没有，就会按照必备参数一个个按顺序填，关键字参数则可以在顺序不对的时候也自动匹配填入
可变参数
使用 * args把所有参数吸收
默认参数
如果不传就用默认值</p>
<h3>模块</h3>
<p>不要用from...import*（命名空间污染）
直接import的时候，加入库名称.函数
补充__name__函数
一个模块被另一个程序第一次引入时，其主程序将运行。</p>
<p>如果我们想在模块被引入时，模块中的某一程序块不执行，我们可以用 <strong>name</strong> 属性来使该程序块仅在该模块自身运行时执行。</p>
<pre><code>#!/usr/bin/python3
# Filename: using_name.py

if __name__ == '__main__':
   print('程序自身在运行')
else:
   print('我来自另一模块')
</code></pre>
<p>运行输出如下：</p>
<pre><code>$ python using_name.py
程序自身在运行

$ python
&gt;&gt;&gt; import using_name
我来自另一模块
</code></pre>
<p>说明：每个模块都有一个 <code>__name__</code> 属性。</p>
<ul>
<li>如果模块是被直接运行，<code>__name__</code> 的值为 <code>__main__</code>。</li>
<li>如果模块是被导入的，<code>__name__</code> 的值为模块名。</li>
</ul>
<h3>推导式</h3>
<pre><code># 列表
[out_exp_res for out_exp in input_list if condition]
[函数 for 变量 in 列表 if 条件]

# 字典
{ key_expr: value_expr for value in collection if condition }

# 集合
{ expression for item in Sequence if conditional }

# 元组
(expression for item in Sequence if conditional)
</code></pre>
<h3>迭代器与生成器</h3>
<h4>iter()</h4>
<p>创建迭代器对象</p>
<h4>next()</h4>
<p>迭代器循环，可以使用 <code>raise StopIteration</code> 来结束迭代</p>
<h4>生成器</h4>
<h5>yield</h5>
<ul>
<li><strong>产出值并暂停：</strong> 当程序执行到 <code>yield</code> 时，它会向调用者返回 <code>yield</code> 后面的值，然后<strong>立刻暂停</strong>在这一行代码，停止向下执行。</li>
<li><strong>保留运行状态：</strong> 函数被暂停时，它内部所有的变量状态、指令指针等都会被完整保留下来。</li>
<li><strong>恢复执行：</strong> 当我们下次再调用 <code>next()</code> 方法请求数据时，代码会从上次 <code>yield</code> 暂停的地方<strong>紧接着往下执行</strong>，直到遇到下一个 <code>yield</code></li>
</ul>
<pre><code>def countdown(n):
    while n &gt; 0:
        yield n
        n -= 1

# 创建生成器对象
generator = countdown(5)

# 通过迭代生成器获取值
print(next(generator))  # 输出: 5
print(next(generator))  # 输出: 4
print(next(generator))  # 输出: 3

# 使用 for 循环迭代生成器
for value in generator:
    print(value)  # 输出: 2 1
</code></pre>
<h3>with 语句</h3>
<p>使用with来管理资源分布</p>
<p>想要使用with的对象需要有<code>__enter__</code> 和<code>__exit__</code>方法，帮助自动处理与释放资源</p>
<pre><code># 同时打开多个文件
with open('input.txt', 'r') as infile, open('output.txt', 'w') as outfile:
    content = infile.read()
    outfile.write(content.upper())
</code></pre>
<h4>最佳实践</h4>
<ol>
<li><strong>优先使用 with 管理资源</strong>：对于文件、网络连接、锁等资源，总是优先考虑使用 <code>with</code> 语句</li>
<li><strong>保持上下文简洁</strong>：<code>with</code> 块中的代码应该只包含与资源相关的操作</li>
<li><strong>合理处理异常</strong>：在自定义上下文管理器中，根据需求决定是否抑制异常</li>
<li><strong>利用多个上下文</strong>：Python 允许在单个 <code>with</code> 语句中管理多个资源</li>
</ol>
<h3>lambda</h3>
<pre><code>lambda arguments: expression
</code></pre>
<pre><code>numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
print(squared)  # 输出: [1, 4, 9, 16, 25]
</code></pre>
<h3>装饰器</h3>
<h4>函数装饰器</h4>
<p>Python 装饰器允许在不修改原有函数代码的基础上，动态地增加或修改函数的功能，装饰器本质上是一个接收函数作为输入并返回一个新的包装过后的函数的对象。
本质上是接收函数返回wrapper</p>
<pre><code>def my_decorator(func):
    def wrapper():
        print("在原函数之前执行")
        func()
        print("在原函数之后执行")
    return wrapper

@my_decorator
def say_hello():
    print("Hello!")

say_hello()
</code></pre>
<p>疑问：return在这里起什么作用？
外层return是my_decorator，作用是把被装饰函数替换成wrapper函数。</p>
<ul>
<li>加上括号 <code>wrapper()</code>：意思是"立刻执行这个函数，并把执行后的<strong>结果</strong>交出去"。</li>
<li>不加括号 <code>wrapper</code>：意思是"我不执行它，我把这个函数的**本体（遥控器）**直接交出去"。</li>
</ul>
<pre><code>def my_decorator(func):
    # 这里是外层函数
    print("【额外逻辑】我在定义时就被执行了！")
    return func  # 只能把原函数原封不动地退回去

@my_decorator
def greet(name):
    print(f"Hello, {name}!")

# 当代码运行到上面 @my_decorator 那里时，屏幕上就已经打印了：
# 【额外逻辑】我在定义时就被执行了！

# 等你真正在下面调用函数时：
greet("Alice")
greet("Bob")

# 屏幕上只会输出：
# Hello, Alice!
# Hello, Bob!
</code></pre>
<p>一般来说，这一块最关键的就是一个 return，和一个内部的内置函数wrapper()，在被定义的时候呢，它这个被装饰 F 就可以执行它这个里特，并且反将被装饰 F 替换成装饰后的函数。
然后以后的话，当我们调用被装饰函数的时候，就是默认被替换成装饰后函数。遵循里面的逻辑，这个装饰后函数我们一般使用就是wrapper</p>
<p>所以在使用可变参数传参的时候，应该遵循这样一个原则：</p>
<p><strong>1. <code>*args</code> (Arguments：位置参数打包器)</strong></p>
<ul>
<li><strong>作用：</strong> 负责把所有按顺序传入的参数，打包成一个<strong>元组 (Tuple)</strong>。</li>
<li><strong>示例：</strong> 如果你调用 <code>func("Alice", 25, "Beijing")</code>，那么在函数内部，<code>args</code> 就会变成 <code>("Alice", 25, "Beijing")</code>。</li>
</ul>
<p><strong>2. <code>**kwargs</code> (Keyword Arguments：关键字参数打包器)</strong></p>
<ul>
<li><strong>作用：</strong> 负责把所有带有名字的参数（如 <code>name="Alice"</code>），打包成一个<strong>字典 (Dictionary)</strong>。</li>
<li><strong>示例：</strong> 如果你调用 <code>func(name="Alice", age=25)</code>，那么在函数内部，<code>kwargs</code> 就会变成 <code>{"name": "Alice", "age": 25}</code>。</li>
</ul>
<h4>类的装饰器</h4>
<table>
<thead>
<tr>
<th><strong>概念</strong></th>
<th><strong>核心标志</strong></th>
<th><strong>作用目标</strong></th>
<th><strong>核心优势</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类装饰器 (用类写)</strong></td>
<td>实现 <code>__init__</code> 和 <code>__call__</code></td>
<td>装饰普通的函数</td>
<td>极其擅长管理复杂的<strong>状态</strong>（如计数、缓存）。</td>
</tr>
<tr>
<td><strong>装饰类的装饰器</strong></td>
<td>接收参数 <code>cls</code> 代替 <code>func</code></td>
<td>装饰一个 Class</td>
<td>批量给类<strong>动态添加属性或方法</strong>，减少重复的模板代码。</td>
</tr>
</tbody>
</table>
<p><code>__call__</code> 等于 wrapper</p>
<pre><code>class Retry:
    def __init__(self, max_times=3):
        # 1. 装配阶段的第一步：记录装饰器传进来的参数
        print(f"【初始化】设置最大重试次数为: {max_times}")
        self.max_times = max_times

    def __call__(self, func):
        # 2. 装配阶段的第二步：接收原函数，并制造替身
        print(f"【装配时】正在给函数 {func.__name__} 穿上重试外套...")

        def wrapper(*args, **kwargs):
            # 3. 调用阶段：真正的重试逻辑
            for attempt in range(1, self.max_times + 1):
                try:
                    print(f"  -&gt; 第 {attempt} 次尝试执行...")
                    result = func(*args, **kwargs)
                    print("  -&gt; 执行成功！")
                    return result  # 成功就直接返回结果，结束循环

                except Exception as e:
                    print(f"  -&gt; 失败了，错误原因: {e}")

            print(f"❌ 警告：已达到最大重试次数 {self.max_times}，彻底放弃。")

        return wrapper  # 把替身交出去

# === 使用场景 ===
print("---- 代码开始加载 ----")

@Retry(max_times=3)
def unstable_network_request():
    # 模拟一个不稳定的网络请求，我们让它故意报错
    raise ConnectionError("网络波动，连接超时！")

print("\n---- 准备调用 ----")
unstable_network_request()
</code></pre>
<p>注意这里存在的身份信息问题：</p>
<pre><code>def my_decorator(func):
    @wraps(func)  # 用这个让wrap继承身份信息
    def wrapper(*args, **kwargs):
        """我是 wrapper 函数的注释"""
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def calculate_tax(amount):
    """这是一个用来计算税务的复杂核心函数"""
    return amount * 0.2

# 此时我们想打印一下函数的名字和注释文档
print(calculate_tax.__name__)
print(calculate_tax.__doc__)
</code></pre>
<table>
<thead>
<tr>
<th><strong>装饰器</strong></th>
<th><strong>第一个参数</strong></th>
<th><strong>能否访问实例属性 (self.xxx)?</strong></th>
<th><strong>能否访问类属性 (cls.xxx)?</strong></th>
<th><strong>最常见使用场景</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>(普通方法)</strong></td>
<td><code>self</code> (实例)</td>
<td>✅ 能</td>
<td>✅ 能 (通过 <code>self.__class__</code>)</td>
<td>操作或修改单个对象的具体状态。</td>
</tr>
<tr>
<td><strong><code>@property</code></strong></td>
<td><code>self</code> (实例)</td>
<td>✅ 能</td>
<td>✅ 能</td>
<td>把方法伪装成只读属性，动态计算值或保护数据。</td>
</tr>
<tr>
<td><strong><code>@classmethod</code></strong></td>
<td><code>cls</code> (类)</td>
<td>❌ 不能</td>
<td>✅ 能</td>
<td>作为"备用构造函数"，或修改全局类状态。</td>
</tr>
<tr>
<td><strong><code>@staticmethod</code></strong></td>
<td>(无固定参数)</td>
<td>❌ 不能</td>
<td>❌ 不能</td>
<td>编写与类逻辑相关，但纯独立的工具函数。</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>少游</name>
    </author>
    <category term="编程语言"></category>
  </entry>
  <entry>
    <title>Git 实战指南：从分支管理到远程协作</title>
    <link href="https://mizuki-sooty.vercel.app/posts/git-practice-guide/" rel="alternate" type="text/html"/>
    <id>https://mizuki-sooty.vercel.app/posts/git-practice-guide/</id>
    <published>2026-02-24T00:00:00.000Z</published>
    <updated>2026-02-24T00:00:00.000Z</updated>
    <summary>从真实开发场景出发，梳理 Git 在分支管理、合并策略、撤销操作与远程协作中的核心实践。</summary>
    <content type="html"><![CDATA[<h1>Git 实战指南：从分支管理到远程协作</h1>
<blockquote>
<p>本文从实际开发场景出发，梳理 Git 在日常工作中最常遇到的操作与决策。不讲花哨技巧，只聚焦「遇到这种情况该怎么办」。</p>
</blockquote>
<hr />
<h2>一、分支：Git 的核心工作单元</h2>
<p>在团队开发中，分支是隔离工作的基本手段。你不会直接在 <code>main</code> 上写代码——你会创建一个分支，在上面开发，完成后再合并回去。</p>
<h3>创建与切换</h3>
<pre><code># 创建并切换到新分支（推荐写法）
git checkout -b feature

# 等价于两步操作
git branch feature
git checkout feature
</code></pre>
<h3>HEAD 是什么？</h3>
<p><code>HEAD</code> 是一个指针，指向你当前所在的分支（或提交）。你做的每一次 <code>checkout</code> 都在移动它。</p>
<ul>
<li><code>HEAD^</code> — 当前提交的父节点</li>
<li><code>HEAD~3</code> — 往前数 3 个提交</li>
<li><code>git branch -f main HEAD~2</code> — 强制把 main 指针移到前 2 个提交</li>
</ul>
<p>下面这张图展示了一个典型的分支工作流——从 <code>main</code> 创建 <code>feature</code> 和 <code>bugfix</code> 分支，独立开发后合并回主干：</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg1_branch_workflow.svg" alt="" /></p>
<hr />
<h2>二、merge vs rebase：最常见的选择困难</h2>
<p>这是 Git 使用中最核心的决策之一。两者都能把代码合到一起，但适用场景完全不同。</p>
<h3>merge：保留历史轨迹</h3>
<pre><code># 在 main 上执行，合并 feature 分支
git checkout main
git merge --no-ff feature
</code></pre>
<p><code>--no-ff</code> 强制生成一个合并提交，即使可以快进。这样在历史中能清楚看到「这个功能是从哪里合进来的」。</p>
<h3>rebase：保持线性历史</h3>
<pre><code># 在 feature 上执行，把自己的改动「垫」到 main 最新提交之上
git checkout feature
git rebase main
</code></pre>
<p>rebase 的本质是：暂存你的提交 → 应用目标分支的更新 → 重新应用你的提交。注意，它修改的是<strong>当前分支</strong>，目标分支只是参照物。</p>
<h3>黄金法则</h3>
<ul>
<li><strong>个人分支用 rebase</strong>：保持干净的线性历史</li>
<li><strong>公共分支用 merge</strong>：保留合并记录，不改写已推送的历史</li>
<li><strong>已推送的分支禁止 rebase</strong>：会导致其他人的历史混乱</li>
</ul>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg2_merge_vs_rebase.svg" alt="" /></p>
<hr />
<h2>三、撤销操作：出了问题怎么办？</h2>
<p>开发中难免会提交错误的代码。关键问题是：<strong>这个提交已经推送到远程了吗？</strong></p>
<h3>仅本地：git reset</h3>
<pre><code># 撤销最近一次提交，保留改动在暂存区
git reset --soft HEAD^

# 撤销最近一次提交，保留改动在工作区（默认行为）
git reset HEAD^

# 彻底丢弃改动（不可恢复！）
git reset --hard HEAD^
</code></pre>
<h3>已推送：git revert</h3>
<pre><code># 生成一个新的「反向提交」来撤销指定提交
git revert &lt;commit-hash&gt;
</code></pre>
<p><code>revert</code> 不会改写历史，而是创建一个新提交来抵消之前的改动。这在协作中是安全的。</p>
<h3>cherry-pick：精确挑选</h3>
<pre><code># 只把 C2 和 C4 这两个提交挪到当前分支
git cherry-pick C2 C4
</code></pre>
<p>区别于 <code>rebase</code> 拿整个分支，<code>cherry-pick</code> 让你精确选择需要的提交。</p>
<h3>交互式 rebase：整理本地提交</h3>
<pre><code>git rebase -i HEAD~4
</code></pre>
<p>可以重排、合并、删除、编辑最近 4 个提交。在推送前整理提交历史非常有用。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg3_undo_decision.svg" alt="" /></p>
<hr />
<h2>四、远程协作：本地与远程的同步</h2>
<h3>核心概念</h3>
<ul>
<li><code>origin/main</code>（简写 <code>o/main</code>）是本地存储的远程仓库快照</li>
<li>它不会自动更新，需要手动 <code>fetch</code></li>
</ul>
<h3>fetch、pull、push 的关系</h3>
<pre><code># 只更新远程跟踪分支，不动本地分支（安全）
git fetch origin

# 拉取并合并（= fetch + merge）
git pull origin main

# 拉取并变基（= fetch + rebase，推荐）
git pull --rebase

# 推送本地提交到远程
git push origin main
</code></pre>
<h3>Remote Tracking：分支跟踪</h3>
<pre><code># 创建本地分支并跟踪远程分支
git checkout -b feature o/main

# 为已有分支设置跟踪
git branch -u o/main feature
</code></pre>
<p>设置跟踪后，<code>git push</code> 和 <code>git pull</code> 就知道该推到哪里、从哪里拉了。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg4_remote_collab.svg" alt="" /></p>
<hr />
<h2>五、push / fetch / pull 参数详解</h2>
<p>这三个命令都支持 <code>origin &lt;source&gt;:&lt;destination&gt;</code> 的参数格式，但方向相反：</p>
<ul>
<li><strong>push</strong>：本地 → 远程（推送空 source = 删除远程分支）</li>
<li><strong>fetch</strong>：远程 → 本地（拉取空 source = 创建本地分支）</li>
</ul>
<pre><code># push 的 source:destination
git push origin main           # 本地 main → 远程 main
git push origin local:remote   # 本地 local → 远程 remote
git push origin :remote        # 删除远程 remote 分支

# fetch 的 source:destination（方向相反）
git fetch origin main           # 远程 main → 本地 o/main
git fetch origin remote:local   # 远程 remote → 本地 local
git fetch origin :local         # 创建本地 local 分支

# pull 是 fetch + merge 的组合
git pull origin foo             # = fetch origin foo + merge o/foo
git pull origin bar:bugFix      # = fetch origin bar:bugFix + merge bugFix
</code></pre>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg5_push_fetch_pull.svg" alt="" /></p>
<hr />
<h2>六、现代 Git 协作利器：worktree</h2>
<h3>为什么需要 worktree？</h3>
<p>在实际开发中，你经常会遇到这样的场景：正在 <code>feature</code> 分支上写代码写到一半，突然线上出了 bug 需要紧急修复。传统做法是 <code>git stash</code> → 切分支 → 修 bug → 切回来 → <code>git stash pop</code>。这个流程有几个痛点：</p>
<ul>
<li>stash 恢复时可能产生冲突</li>
<li>IDE 的构建缓存、运行状态全部丢失</li>
<li>频繁切换分支的心智负担很重</li>
</ul>
<p><code>git worktree</code> 从根本上解决了这个问题：它允许你从同一个仓库创建多个工作目录，每个目录检出不同的分支，彼此完全独立。</p>
<h3>核心设计理念</h3>
<p>worktree 的设计哲学是<strong>共享存储，隔离工作区</strong>：</p>
<ul>
<li>所有工作树共享同一个 <code>.git</code> 对象库（commits、blobs、trees）</li>
<li>每个工作树有独立的 <code>HEAD</code>、<code>index</code>（暂存区）和工作目录</li>
<li>磁盘开销极小——只多了一份工作区文件，不会复制整个仓库</li>
</ul>
<p>这意味着你在任何一个工作树中做的提交，其他工作树都能立即看到（通过 <code>git log</code>），因为底层数据是共享的。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg6_worktree_concept.svg" alt="" /></p>
<h3>实战场景对比</h3>
<p>下面这张图对比了传统方式和 worktree 方式处理「开发中途需要修 bug」的流程差异：</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg7_worktree_workflow.svg" alt="" /></p>
<h3>常用命令速查</h3>
<pre><code># 创建一个新的工作树，检出 hotfix 分支
git worktree add ../project-hotfix hotfix

# 创建工作树的同时创建新分支
git worktree add -b emergency-fix ../project-fix main

# 查看所有工作树
git worktree list

# 完成后移除工作树（先删目录再清理引用）
git worktree remove ../project-hotfix

# 清理已失效的工作树引用
git worktree prune
</code></pre>
<h3>使用注意事项</h3>
<ul>
<li><strong>同一分支不能同时被两个工作树检出</strong>——这是 Git 的硬性限制，防止两个工作区同时修改同一分支导致混乱</li>
<li><strong>不要直接 <code>rm -rf</code> 删除工作树目录</strong>——应该用 <code>git worktree remove</code>，否则 <code>.git/worktrees</code> 中会残留失效引用</li>
<li>子模块在链接工作树中的支持有限，复杂项目需要测试验证</li>
<li>worktree 非常适合 CI/CD 场景——可以同时构建多个分支而不互相干扰</li>
</ul>
<h3>什么时候该用 worktree？</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发中途需要紧急修 bug</td>
<td>✅ 最佳场景</td>
</tr>
<tr>
<td>需要同时对比两个分支的运行效果</td>
<td>✅ 非常适合</td>
</tr>
<tr>
<td>长期维护多个版本（v1、v2）</td>
<td>✅ 比多个 clone 更轻量</td>
</tr>
<tr>
<td>CI 并行构建多个分支</td>
<td>✅ 共享对象库，节省空间</td>
</tr>
<tr>
<td>只是简单切个分支看一眼</td>
<td>❌ 直接 checkout 更快</td>
</tr>
</tbody>
</table>
<hr />
<h2>七、实战工作流总结</h2>
<h3>日常开发流程</h3>
<ol>
<li><code>git fetch origin</code> — 先看看远程有什么变化</li>
<li><code>git rebase o/main</code> — 在个人分支上变基到最新</li>
<li>解决可能的冲突</li>
<li><code>git push</code> — 推送到远程</li>
<li>在 <code>main</code> 上 <code>merge --no-ff</code> — 合并功能分支</li>
</ol>
<h3>版本标记</h3>
<pre><code># 给特定提交打标签
git tag v1.0.0 &lt;commit-hash&gt;

# 查看离当前位置最近的标签
git describe main
</code></pre>
<h3>常见陷阱</h3>
<table>
<thead>
<tr>
<th>陷阱</th>
<th>后果</th>
<th>正确做法</th>
</tr>
</thead>
<tbody>
<tr>
<td>在公共分支上 rebase</td>
<td>其他人的历史被打乱</td>
<td>只在个人分支 rebase</td>
</tr>
<tr>
<td>rebase 时搞反目标和参考分支</td>
<td>提交顺序错乱</td>
<td>仔细确认当前分支和目标分支</td>
</tr>
<tr>
<td>reset --hard 后想恢复</td>
<td>改动永久丢失</td>
<td>先确认不需要，或用 reflog 抢救</td>
</tr>
<tr>
<td>push 空 source 到远程</td>
<td>远程分支被删除</td>
<td>检查命令参数再执行</td>
</tr>
</tbody>
</table>
<hr />
<blockquote>
<p>记住两条核心原则：<strong>个人分支随便折腾，公共分支只做加法</strong>。掌握了 merge/rebase 的选择和 reset/revert 的区分，日常 Git 操作就不会出大问题。</p>
</blockquote>
]]></content>
    <author>
      <name>少游</name>
    </author>
    <category term="开发工具"></category>
  </entry>
</feed>