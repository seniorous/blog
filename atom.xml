<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>少游的博客</title>
  <subtitle>去追寻吧，你所期待的那颗星</subtitle>
  <link href="https://mizuki-sooty.vercel.app/" rel="alternate" type="text/html"/>
  <link href="https://mizuki-sooty.vercel.app/atom.xml" rel="self" type="application/atom+xml"/>
  <id>https://mizuki-sooty.vercel.app/</id>
  <updated>2026-02-25T13:53:04.854Z</updated>
  <language>zh_CN</language>
  <entry>
    <title>Git 实战指南：从分支管理到远程协作</title>
    <link href="https://mizuki-sooty.vercel.app/posts/git-practice-guide/" rel="alternate" type="text/html"/>
    <id>https://mizuki-sooty.vercel.app/posts/git-practice-guide/</id>
    <published>2026-02-24T00:00:00.000Z</published>
    <updated>2026-02-24T00:00:00.000Z</updated>
    <summary>从真实开发场景出发，梳理 Git 在分支管理、合并策略、撤销操作与远程协作中的核心实践。</summary>
    <content type="html"><![CDATA[<h1>Git 实战指南：从分支管理到远程协作</h1>
<blockquote>
<p>本文从实际开发场景出发，梳理 Git 在日常工作中最常遇到的操作与决策。不讲花哨技巧，只聚焦「遇到这种情况该怎么办」。</p>
</blockquote>
<hr />
<h2>一、分支：Git 的核心工作单元</h2>
<p>在团队开发中，分支是隔离工作的基本手段。你不会直接在 <code>main</code> 上写代码——你会创建一个分支，在上面开发，完成后再合并回去。</p>
<h3>创建与切换</h3>
<pre><code># 创建并切换到新分支（推荐写法）
git checkout -b feature

# 等价于两步操作
git branch feature
git checkout feature
</code></pre>
<h3>HEAD 是什么？</h3>
<p><code>HEAD</code> 是一个指针，指向你当前所在的分支（或提交）。你做的每一次 <code>checkout</code> 都在移动它。</p>
<ul>
<li><code>HEAD^</code> — 当前提交的父节点</li>
<li><code>HEAD~3</code> — 往前数 3 个提交</li>
<li><code>git branch -f main HEAD~2</code> — 强制把 main 指针移到前 2 个提交</li>
</ul>
<p>下面这张图展示了一个典型的分支工作流——从 <code>main</code> 创建 <code>feature</code> 和 <code>bugfix</code> 分支，独立开发后合并回主干：</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg1_branch_workflow.svg" alt="" /></p>
<hr />
<h2>二、merge vs rebase：最常见的选择困难</h2>
<p>这是 Git 使用中最核心的决策之一。两者都能把代码合到一起，但适用场景完全不同。</p>
<h3>merge：保留历史轨迹</h3>
<pre><code># 在 main 上执行，合并 feature 分支
git checkout main
git merge --no-ff feature
</code></pre>
<p><code>--no-ff</code> 强制生成一个合并提交，即使可以快进。这样在历史中能清楚看到「这个功能是从哪里合进来的」。</p>
<h3>rebase：保持线性历史</h3>
<pre><code># 在 feature 上执行，把自己的改动「垫」到 main 最新提交之上
git checkout feature
git rebase main
</code></pre>
<p>rebase 的本质是：暂存你的提交 → 应用目标分支的更新 → 重新应用你的提交。注意，它修改的是<strong>当前分支</strong>，目标分支只是参照物。</p>
<h3>黄金法则</h3>
<ul>
<li><strong>个人分支用 rebase</strong>：保持干净的线性历史</li>
<li><strong>公共分支用 merge</strong>：保留合并记录，不改写已推送的历史</li>
<li><strong>已推送的分支禁止 rebase</strong>：会导致其他人的历史混乱</li>
</ul>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg2_merge_vs_rebase.svg" alt="" /></p>
<hr />
<h2>三、撤销操作：出了问题怎么办？</h2>
<p>开发中难免会提交错误的代码。关键问题是：<strong>这个提交已经推送到远程了吗？</strong></p>
<h3>仅本地：git reset</h3>
<pre><code># 撤销最近一次提交，保留改动在暂存区
git reset --soft HEAD^

# 撤销最近一次提交，保留改动在工作区（默认行为）
git reset HEAD^

# 彻底丢弃改动（不可恢复！）
git reset --hard HEAD^
</code></pre>
<h3>已推送：git revert</h3>
<pre><code># 生成一个新的「反向提交」来撤销指定提交
git revert &lt;commit-hash&gt;
</code></pre>
<p><code>revert</code> 不会改写历史，而是创建一个新提交来抵消之前的改动。这在协作中是安全的。</p>
<h3>cherry-pick：精确挑选</h3>
<pre><code># 只把 C2 和 C4 这两个提交挪到当前分支
git cherry-pick C2 C4
</code></pre>
<p>区别于 <code>rebase</code> 拿整个分支，<code>cherry-pick</code> 让你精确选择需要的提交。</p>
<h3>交互式 rebase：整理本地提交</h3>
<pre><code>git rebase -i HEAD~4
</code></pre>
<p>可以重排、合并、删除、编辑最近 4 个提交。在推送前整理提交历史非常有用。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg3_undo_decision.svg" alt="" /></p>
<hr />
<h2>四、远程协作：本地与远程的同步</h2>
<h3>核心概念</h3>
<ul>
<li><code>origin/main</code>（简写 <code>o/main</code>）是本地存储的远程仓库快照</li>
<li>它不会自动更新，需要手动 <code>fetch</code></li>
</ul>
<h3>fetch、pull、push 的关系</h3>
<pre><code># 只更新远程跟踪分支，不动本地分支（安全）
git fetch origin

# 拉取并合并（= fetch + merge）
git pull origin main

# 拉取并变基（= fetch + rebase，推荐）
git pull --rebase

# 推送本地提交到远程
git push origin main
</code></pre>
<h3>Remote Tracking：分支跟踪</h3>
<pre><code># 创建本地分支并跟踪远程分支
git checkout -b feature o/main

# 为已有分支设置跟踪
git branch -u o/main feature
</code></pre>
<p>设置跟踪后，<code>git push</code> 和 <code>git pull</code> 就知道该推到哪里、从哪里拉了。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg4_remote_collab.svg" alt="" /></p>
<hr />
<h2>五、push / fetch / pull 参数详解</h2>
<p>这三个命令都支持 <code>origin &lt;source&gt;:&lt;destination&gt;</code> 的参数格式，但方向相反：</p>
<ul>
<li><strong>push</strong>：本地 → 远程（推送空 source = 删除远程分支）</li>
<li><strong>fetch</strong>：远程 → 本地（拉取空 source = 创建本地分支）</li>
</ul>
<pre><code># push 的 source:destination
git push origin main           # 本地 main → 远程 main
git push origin local:remote   # 本地 local → 远程 remote
git push origin :remote        # 删除远程 remote 分支

# fetch 的 source:destination（方向相反）
git fetch origin main           # 远程 main → 本地 o/main
git fetch origin remote:local   # 远程 remote → 本地 local
git fetch origin :local         # 创建本地 local 分支

# pull 是 fetch + merge 的组合
git pull origin foo             # = fetch origin foo + merge o/foo
git pull origin bar:bugFix      # = fetch origin bar:bugFix + merge bugFix
</code></pre>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg5_push_fetch_pull.svg" alt="" /></p>
<hr />
<h2>六、现代 Git 协作利器：worktree</h2>
<h3>为什么需要 worktree？</h3>
<p>在实际开发中，你经常会遇到这样的场景：正在 <code>feature</code> 分支上写代码写到一半，突然线上出了 bug 需要紧急修复。传统做法是 <code>git stash</code> → 切分支 → 修 bug → 切回来 → <code>git stash pop</code>。这个流程有几个痛点：</p>
<ul>
<li>stash 恢复时可能产生冲突</li>
<li>IDE 的构建缓存、运行状态全部丢失</li>
<li>频繁切换分支的心智负担很重</li>
</ul>
<p><code>git worktree</code> 从根本上解决了这个问题：它允许你从同一个仓库创建多个工作目录，每个目录检出不同的分支，彼此完全独立。</p>
<h3>核心设计理念</h3>
<p>worktree 的设计哲学是<strong>共享存储，隔离工作区</strong>：</p>
<ul>
<li>所有工作树共享同一个 <code>.git</code> 对象库（commits、blobs、trees）</li>
<li>每个工作树有独立的 <code>HEAD</code>、<code>index</code>（暂存区）和工作目录</li>
<li>磁盘开销极小——只多了一份工作区文件，不会复制整个仓库</li>
</ul>
<p>这意味着你在任何一个工作树中做的提交，其他工作树都能立即看到（通过 <code>git log</code>），因为底层数据是共享的。</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg6_worktree_concept.svg" alt="" /></p>
<h3>实战场景对比</h3>
<p>下面这张图对比了传统方式和 worktree 方式处理「开发中途需要修 bug」的流程差异：</p>
<p><img src="https://mizuki-sooty.vercel.app/images/git-practice-guide/svg7_worktree_workflow.svg" alt="" /></p>
<h3>常用命令速查</h3>
<pre><code># 创建一个新的工作树，检出 hotfix 分支
git worktree add ../project-hotfix hotfix

# 创建工作树的同时创建新分支
git worktree add -b emergency-fix ../project-fix main

# 查看所有工作树
git worktree list

# 完成后移除工作树（先删目录再清理引用）
git worktree remove ../project-hotfix

# 清理已失效的工作树引用
git worktree prune
</code></pre>
<h3>使用注意事项</h3>
<ul>
<li><strong>同一分支不能同时被两个工作树检出</strong>——这是 Git 的硬性限制，防止两个工作区同时修改同一分支导致混乱</li>
<li><strong>不要直接 <code>rm -rf</code> 删除工作树目录</strong>——应该用 <code>git worktree remove</code>，否则 <code>.git/worktrees</code> 中会残留失效引用</li>
<li>子模块在链接工作树中的支持有限，复杂项目需要测试验证</li>
<li>worktree 非常适合 CI/CD 场景——可以同时构建多个分支而不互相干扰</li>
</ul>
<h3>什么时候该用 worktree？</h3>
<table>
<thead>
<tr>
<th>场景</th>
<th>是否推荐</th>
</tr>
</thead>
<tbody>
<tr>
<td>开发中途需要紧急修 bug</td>
<td>✅ 最佳场景</td>
</tr>
<tr>
<td>需要同时对比两个分支的运行效果</td>
<td>✅ 非常适合</td>
</tr>
<tr>
<td>长期维护多个版本（v1、v2）</td>
<td>✅ 比多个 clone 更轻量</td>
</tr>
<tr>
<td>CI 并行构建多个分支</td>
<td>✅ 共享对象库，节省空间</td>
</tr>
<tr>
<td>只是简单切个分支看一眼</td>
<td>❌ 直接 checkout 更快</td>
</tr>
</tbody>
</table>
<hr />
<h2>七、实战工作流总结</h2>
<h3>日常开发流程</h3>
<ol>
<li><code>git fetch origin</code> — 先看看远程有什么变化</li>
<li><code>git rebase o/main</code> — 在个人分支上变基到最新</li>
<li>解决可能的冲突</li>
<li><code>git push</code> — 推送到远程</li>
<li>在 <code>main</code> 上 <code>merge --no-ff</code> — 合并功能分支</li>
</ol>
<h3>版本标记</h3>
<pre><code># 给特定提交打标签
git tag v1.0.0 &lt;commit-hash&gt;

# 查看离当前位置最近的标签
git describe main
</code></pre>
<h3>常见陷阱</h3>
<table>
<thead>
<tr>
<th>陷阱</th>
<th>后果</th>
<th>正确做法</th>
</tr>
</thead>
<tbody>
<tr>
<td>在公共分支上 rebase</td>
<td>其他人的历史被打乱</td>
<td>只在个人分支 rebase</td>
</tr>
<tr>
<td>rebase 时搞反目标和参考分支</td>
<td>提交顺序错乱</td>
<td>仔细确认当前分支和目标分支</td>
</tr>
<tr>
<td>reset --hard 后想恢复</td>
<td>改动永久丢失</td>
<td>先确认不需要，或用 reflog 抢救</td>
</tr>
<tr>
<td>push 空 source 到远程</td>
<td>远程分支被删除</td>
<td>检查命令参数再执行</td>
</tr>
</tbody>
</table>
<hr />
<blockquote>
<p>记住两条核心原则：<strong>个人分支随便折腾，公共分支只做加法</strong>。掌握了 merge/rebase 的选择和 reset/revert 的区分，日常 Git 操作就不会出大问题。</p>
</blockquote>
]]></content>
    <author>
      <name>少游</name>
    </author>
    <category term="开发工具"></category>
  </entry>
</feed>